<!DOCTYPE html>
<html>
<head>
    <title>Climbing Route Identifier</title>
    <link rel="stylesheet" href="static/styles.css">
</head>
<body>
    <h1>Climbing Route Detector</h1>

    <form action="/" method="POST" enctype="multipart/form-data">
        <div style="text-align: center; margin-bottom: 20px;">
            <input type="file" name="image" id="fileInput" required>
            <label for="fileInput" class="button">Choose image</label><br><br>
        </div>

        <!-- Preview size slider -->
        <div style="text-align: center; margin-bottom: 20px;">
            <label for="imgSize">Preview image size</label><br>
            <input type="range" id="imgSize" min="100" max="800" value="400">
            <span id="imgSizeValue">400 px</span>
        </div>

        <h2>Live Preview</h2>
        <div class="preview-options">
            <div class="preview-panel">
                <img id="preview" src="" width="400" style="display: none;"><br>
                <p id="status"></p>
            </div>
    
            <div class="options">
                <!-- Hue -->
                <label>
                    Hue Range
                    (<span id="h_summary">0 – 179</span>)
                </label><br>
                <input type="range" name="h_min" id="h_min" min="0" max="179" value="0" data-display="h_min_val">
                <span id="h_min_val">0</span><br>
                <input type="range" name="h_max" id="h_max" min="0" max="179" value="179" data-display="h_max_val">
                <span id="h_max_val">179</span><br><br>
            
                <!-- Saturation -->
                <label>
                    Saturation Range
                    (<span id="s_summary">40 – 255</span>)
                </label><br>
                <input type="range" name="s_min" id="s_min" min="0" max="255" value="40" data-display="s_min_val">
                <span id="s_min_val">40</span><br>
                <input type="range" name="s_max" id="s_max" min="0" max="255" value="255" data-display="s_max_val">
                <span id="s_max_val">255</span><br><br>
            
                <!-- Value / Brightness -->
                <label>
                    Value (Brightness) Range
                    (<span id="v_summary">60 – 255</span>)
                </label><br>
                <input type="range" name="v_min" id="v_min" min="0" max="255" value="60" data-display="v_min_val">
                <span id="v_min_val">60</span><br>
                <input type="range" name="v_max" id="v_max" min="0" max="255" value="255" data-display="v_max_val">
                <span id="v_max_val">255</span><br><br>
            
                <!-- Morphology kernels -->
                <label>
                    Morphology Kernel Sizes
                    (<span id="k_summary">open 3, close 7</span>)
                </label><br>
                Open:
                <input type="range" name="open_k" id="open_k" min="1" max="15" value="3" data-display="open_k_val">
                <span id="open_k_val">3</span><br>
                Close:
                <input type="range" name="close_k" id="close_k" min="1" max="21" value="7" data-display="close_k_val">
                <span id="close_k_val">7</span><br><br>
            
                <!-- Min area -->
                <label>
                    Min Area
                    (<span id="area_summary">150 px²</span>)
                </label><br>
                <input type="range" name="area_min" id="area_min" min="0" max="5000" value="150" step="10" data-display="area_min_val">
                <span id="area_min_val">150</span><br><br>
            
                <!-- CLAHE toggle -->
                <label>
                    Use CLAHE?
                    (<span id="clahe_summary">on</span>)
                </label>
                <input type="checkbox" name="clahe" id="clahe" checked><br><br>
            
                <div class="submit-row">
                    <button type="submit" class="button">Generate</button>
                </div>
            </div>
        </div>
    </form>

    {% if result_image %}
    <h2>Result</h2>

    <div class="result">
        <!-- NEW: wrapper for image + canvas -->
        <div class="result-img-wrapper">
            <img id="resultImage" class="resultImage"
                 src="{{ url_for('processed_file', filename=result_image) }}" width="400">
            <canvas id="holdCanvas"></canvas>
        </div>
        
        <!-- Result size slider (unchanged) -->
        <div class="sizeSlider">
            <label for="resultSize">Result image size</label><br>
            <input type="range" id="resultSize" min="100" max="800" value="400">
            <span id="resultSizeValue">400 px</span>
        </div>
    </div>

    <div class="submit-row">
        <button type="button" id="monoButton" class="button">
            Dim selected holds
        </button>
        <button type="button" id="exportButton" class="button">
            Export Image
        </button>
    </div>

    <p>{{ num_detected }} climbing holds detected.</p>

    <!-- NEW: show selected count -->
    <p>Selected holds: <span id="selectedCount">0</span></p>

    <!-- NEW: embed holds data JSON -->
    <script id="holdData" type="application/json">
        {{ components_json|safe }}
    </script>
{% endif %}

    <script>
        const form = document.querySelector("form");
        const previewImg = document.getElementById("preview");
        const statusText = document.getElementById("status");
        const sizeSlider = document.getElementById("imgSize");
        const sizeValue = document.getElementById("imgSizeValue");
        const resultImg = document.getElementById("resultImage");
        const resultSizeSlider = document.getElementById("resultSize");
        const resultSizeValue = document.getElementById("resultSizeValue");

        function applyPreviewSize(width) {
            if (previewImg) {
                previewImg.style.width = width + "px";
            }
        }

        function applyResultSize(width) {
            if (resultImg) {
                resultImg.style.width = width + "px";
            }
        }

        // Initialize preview size on load
        if (sizeSlider) {
            applyPreviewSize(sizeSlider.value);
            sizeSlider.addEventListener("input", () => {
                const w = sizeSlider.value;
                sizeValue.textContent = w + " px";
                applyPreviewSize(w);
            });
        }

        // Initialize result size on load (only if result is present)
        if (resultSizeSlider) {
            applyResultSize(resultSizeSlider.value);
            resultSizeValue.textContent = resultSizeSlider.value + " px";

            resultSizeSlider.addEventListener("input", () => {
                const w = resultSizeSlider.value;
                resultSizeValue.textContent = w + " px";
                applyResultSize(w);
            });
        }

        // Attach event listeners to all form inputs *that have a name* (exclude size slider)
        const inputs = form.querySelectorAll("input[name]");
        inputs.forEach(input => {
            input.addEventListener("input", () => {
                generatePreview();
            });
        });

        // Per-slider numeric displays and summaries
        const rangeInputsWithDisplay = document.querySelectorAll('input[type="range"][data-display]');
        rangeInputsWithDisplay.forEach(slider => {
            const span = document.getElementById(slider.dataset.display);
            const updateDisplay = () => {
                if (span) span.textContent = slider.value;
                updateSummaries();
            };
            slider.addEventListener("input", updateDisplay);
            updateDisplay(); // initial
        });

        const claheCheckbox = document.getElementById("clahe");
        if (claheCheckbox) {
            claheCheckbox.addEventListener("change", () => {
                updateSummaries();
                generatePreview();
            });
        }

        function updateSummaries() {
            const hMin = document.getElementById("h_min").value;
            const hMax = document.getElementById("h_max").value;
            const sMin = document.getElementById("s_min").value;
            const sMax = document.getElementById("s_max").value;
            const vMin = document.getElementById("v_min").value;
            const vMax = document.getElementById("v_max").value;
            const openK = document.getElementById("open_k").value;
            const closeK = document.getElementById("close_k").value;
            const areaMin = document.getElementById("area_min").value;
            const claheOn = document.getElementById("clahe").checked;

            document.getElementById("h_summary").textContent = `${hMin} – ${hMax}`;
            document.getElementById("s_summary").textContent = `${sMin} – ${sMax}`;
            document.getElementById("v_summary").textContent = `${vMin} – ${vMax}`;
            document.getElementById("k_summary").textContent = `open ${openK}, close ${closeK}`;
            document.getElementById("area_summary").textContent = `${areaMin} px²`;
            document.getElementById("clahe_summary").textContent = claheOn ? "on" : "off";
        }

        // Initial summaries on load
        updateSummaries();

        function generatePreview() {
            const formData = new FormData(form);

            fetch("/preview", {
                method: "POST",
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.preview_url) {
                    previewImg.src = data.preview_url + "?t=" + new Date().getTime();  // prevent caching
                    previewImg.style.display = "block";
                    statusText.innerText = `${data.num_detected} holds detected.`;
                    // Keep preview width in sync with slider
                    if (sizeSlider) {
                        applyPreviewSize(sizeSlider.value);
                    }
                } else {
                    statusText.innerText = "Error generating preview.";
                }
            })
            .catch(err => {
                console.error(err);
                statusText.innerText = "Preview failed.";
            });
        }

        // -------- HOLD SELECTION CANVAS LOGIC (NEW) --------
        const holdDataScript = document.getElementById("holdData");
        let holds = [];
        let selected = new Set();
        let ctx = null;

        function drawHolds() {
            const canvas = document.getElementById("holdCanvas");
            const img = document.getElementById("resultImage");
            if (!canvas || !img || !ctx || !holds.length) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const scaleX = img.clientWidth / img.naturalWidth;
            const scaleY = img.clientHeight / img.naturalHeight;
            const scale = (scaleX + scaleY) / 2;

            holds.forEach(h => {
                const x = h.cx * scaleX;
                const y = h.cy * scaleY;
                const radius = 8 * scale;

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.lineWidth = 2;

                if (selected.has(h.id)) {
                    ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // red translucent fill
                    ctx.strokeStyle = "red";
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = "lime";               // green outline
                    ctx.stroke();
                }
            });
        }

        function initHoldCanvas() {
            if (!holdDataScript) return;
            const canvas = document.getElementById("holdCanvas");
            const img = document.getElementById("resultImage");
            const selectedCountEl = document.getElementById("selectedCount");
            if (!canvas || !img || !selectedCountEl) return;

            try {
                holds = JSON.parse(holdDataScript.textContent || "[]");
                holds = holds.map((h, i) => ({ ...h, id: i }));
            } catch (e) {
                holds = [];
            }

            ctx = canvas.getContext("2d");

            function resizeCanvas() {
                canvas.width = img.clientWidth;
                canvas.height = img.clientHeight;
                drawHolds();
            }
            const resultSizeSlider = document.getElementById("resultSize");
            if (resultSizeSlider) {
                resultSizeSlider.addEventListener("input", () => {
                    resizeCanvas();
                });
            }
            function updateSelectedCount() {
                selectedCountEl.textContent = selected.size;
            }

            canvas.addEventListener("click", (evt) => {
                const rect = canvas.getBoundingClientRect();
                const x = evt.clientX - rect.left;
                const y = evt.clientY - rect.top;

                const imgW = img.clientWidth;
                const imgH = img.clientHeight;
                const scaleX = imgW / img.naturalWidth;
                const scaleY = imgH / img.naturalHeight;
                const scale = (scaleX + scaleY) / 2;

                let hitId = null;
                holds.forEach(h => {
                    const hx = h.cx * scaleX;
                    const hy = h.cy * scaleY;
                    const radius = 10 * scale;
                    const dx = x - hx;
                    const dy = y - hy;
                    if (dx * dx + dy * dy <= radius * radius) {
                        hitId = h.id;
                    }
                });

                if (hitId !== null) {
                    if (selected.has(hitId)) {
                        selected.delete(hitId);
                    } else {
                        selected.add(hitId);
                    }
                    updateSelectedCount();
                    drawHolds();
                }
            });

            img.addEventListener("load", () => {
                resizeCanvas();
                updateSelectedCount();
            });

            if (img.complete) {
                resizeCanvas();
                updateSelectedCount();
            }

            window.addEventListener("resize", resizeCanvas);
        }

        // Run once on page load (only does something when result_image exists)
        initHoldCanvas();


        const monoButton = document.getElementById("monoButton");
        const holdCanvas = document.getElementById("holdCanvas");

        if (monoButton && holdCanvas && resultImg) {
            monoButton.addEventListener("click", () => {
                if (!holds.length) return;

                // If nothing is selected, do nothing (or show a hint)
                if (selected.size === 0) {
                    alert("Click on holds to select them before dimming.");
                    return;
                }

                const naturalW = resultImg.naturalWidth;
                const naturalH = resultImg.naturalHeight;
                if (!naturalW || !naturalH) return;

                const baseCanvas = document.createElement("canvas");
                baseCanvas.width = naturalW;
                baseCanvas.height = naturalH;
                const monoCtx = baseCanvas.getContext("2d");

                // Draw current colored image at full res
                monoCtx.drawImage(resultImg, 0, 0, naturalW, naturalH);

                const imageData = monoCtx.getImageData(0, 0, naturalW, naturalH);
                const data = imageData.data;

                // Precompute selected holds and their radii in ORIGINAL coords
                const coloredHolds = holds
                    .filter(h => !selected.has(h.id))
                    .map(h => {
                        // Estimate radius from area (area ~= π r²)
                        const rawR = Math.sqrt((h.area || 100) / Math.PI);
                        // give it a little buffer so we actually see color
                        const radius = Math.max(6, rawR * 1.1);
                        return {
                            cx: h.cx,
                            cy: h.cy,
                            r: radius,
                            r2: radius * radius
                        };
                    });

                if (coloredHolds.length === 0) {
                    // Safety net: if somehow no selected holds made it through
                    alert("No valid selected holds found.");
                    return;
                }

                // For each pixel: if inside ANY selected circle → keep color
                // otherwise convert to grayscale
                for (let y = 0; y < naturalH; y++) {
                    for (let x = 0; x < naturalW; x++) {
                        const idx = (y * naturalW + x) * 4;

                        // Check membership in any selected hold
                        let insideColored = false;
                        for (let i = 0; i < coloredHolds.length; i++) {
                            const h = coloredHolds[i];
                            const dx = x - h.cx;
                            const dy = y - h.cy;
                            if (dx * dx + dy * dy <= h.r2) {
                                insideColored = true;
                                break;
                            }
                        }

                        if (!insideColored) {
                            const r = data[idx];
                            const g = data[idx + 1];
                            const b = data[idx + 2];
                            const a = data[idx + 3];
                            const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                            data[idx]     = lum;
                            data[idx + 1] = lum;
                            data[idx + 2] = lum;
                            data[idx + 3] = a;
                        }
                        // else: leave RGB as-is (colored)
                    }
                }

                // Put the adjusted pixels back and update the <img>
                monoCtx.putImageData(imageData, 0, 0);
                resultImg.src = baseCanvas.toDataURL("image/png");
            });
        }

        const exportButton = document.getElementById("exportButton");

        if (exportButton && resultImg) {
            exportButton.addEventListener("click", () => {
                if (!resultImg.src) {
                    alert("No image to export yet.");
                    return;
                }

                // Create a temporary link and trigger download
                const link = document.createElement("a");
                link.href = resultImg.src;
                link.download = "climb_route.png";  // file name
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        }
    </script>
</body>
</html>